export const blogPosts = [
    {
      title: `Sockets or How Processes Communicate`,
      description: `An introduction to socket programming, covering TCP/UDP protocols, client-server architecture, and inter-process communication fundamentals.`, 
      date: `2025-08-05`,
      readTime: `8 min read`,
      category: `Network Programming`,
      link: `#`,
      slug: `sockets-or-how-processes-communicate`,
      tags: [`Sockets`, `TCP`, `UDP`, `System Programming`],
      content: `# Sockets or How Processes Communicate\n\nSocket programming is a fundamental concept in network programming that enables processes to communicate with each other across networks. Whether you're building web applications, distributed systems, or real-time communication tools, understanding sockets is crucial for any backend developer.\n\n## What are Sockets?\n\nA socket is an endpoint for communication between two machines. Think of it as a telephone connection - one process \"calls\" another process, and once the connection is established, they can exchange data bidirectionally.\n\n## Types of Sockets\n\n### TCP Sockets (Stream Sockets)\n- **Reliable**: Guarantees data delivery and order\n- **Connection-oriented**: Establishes a connection before data transfer\n- **Use cases**: Web browsers, email, file transfers\n\n### UDP Sockets (Datagram Sockets)  \n- **Fast**: Lower overhead, no connection establishment\n- **Unreliable**: No guarantee of delivery or order\n- **Use cases**: Gaming, live streaming, DNS lookups\n\n## Socket Programming Fundamentals\n\n### Server-Side Implementation\n\n```python\nimport socket\n\n# Create socket\nserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Bind to address and port\nserver_socket.bind(('localhost', 8080))\n\n# Listen for connections\nserver_socket.listen(5)\n\nwhile True:\n    client_socket, address = server_socket.accept()\n    data = client_socket.recv(1024)\n    client_socket.send(b"Hello from server!")\n    client_socket.close()\n\n```\n\n### Client-Side Implementation\n\n```python\nimport socket\n\n# Create socket\nclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n# Connect to server\nclient_socket.connect(('localhost', 8080))\n\n# Send data\nclient_socket.send(b"Hello from client!")\n\n# Receive response\nresponse = client_socket.recv(1024)\nprint(response.decode())\n\nclient_socket.close()\n\n```\n\n## Best Practices\n\n1. **Error Handling**: Always implement proper error handling for network operations\n2. **Resource Management**: Close sockets properly to avoid resource leaks\n3. **Security**: Validate input data and implement authentication when needed\n4. **Performance**: Use connection pooling for high-traffic applications\n\n## Real-World Applications\n\nSocket programming powers many technologies we use daily:\n- **Web Servers**: HTTP communication between browsers and servers\n- **Chat Applications**: Real-time messaging systems\n- **Database Connections**: Client-server database communication\n- **API Services**: RESTful and GraphQL API endpoints\n\nUnderstanding sockets gives you the foundation to build robust, scalable network applications and debug network-related issues effectively.`,
    },
    {
      title: `Building Secure REST APIs`,
      description: `Best practices for implementing authentication, authorization, and security measures in modern web APIs.`, 
      date: `2025-07-20`,
      readTime: `12 min read`, 
      category: `Backend Development`,
      link: `#`,
      slug: `building-secure-rest-apis`,
      tags: [`REST API`, `Security`, `JWT`, `RBAC`],
      content: `# Building Secure REST APIs\n\nSecurity should never be an afterthought when building REST APIs. In today's threat landscape, implementing robust security measures from the ground up is essential for protecting user data and maintaining system integrity.\n\n## Authentication vs Authorization\n\n**Authentication** answers \"Who are you?\"\n**Authorization** answers \"What can you do?\"\n\nBoth are crucial but serve different purposes in your security architecture.\n\n## JWT (JSON Web Tokens)\n\nJWTs provide a stateless authentication mechanism:\n\n```javascript\nconst jwt = require('jsonwebtoken');\n\n// Generate token\nconst token = jwt.sign(\n  { userId: user.id, role: user.role },\n  process.env.JWT_SECRET,\n  { expiresIn: '24h' }\n);\n\n// Verify token middleware\nconst verifyToken = (req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  if (!token) {\n    return res.status(401).json({ error: 'Access denied' });\n  }\n  \n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    req.user = decoded;\n    next();\n  } catch (error) {\n    res.status(400).json({ error: 'Invalid token' });\n  }\n};\n\n```\n\n## Role-Based Access Control (RBAC)\n\nImplement granular permissions:\n\n```javascript\nconst authorize = (roles) => {\n  return (req, res, next) => {\n    if (!roles.includes(req.user.role)) {\n      return res.status(403).json({ error: 'Insufficient permissions' });\n    }\n    next();\n  };\n};\n\n// Usage\napp.get('/admin/users', verifyToken, authorize(['admin']), getUsersController);\napp.post('/posts', verifyToken, authorize(['user', 'admin']), createPostController);\n\n```\n\n## Input Validation\n\nNever trust user input:\n\n```javascript\nconst { body, validationResult } = require('express-validator');\n\nconst validateUser = [\n  body('email').isEmail().normalizeEmail(),\n  body('password').isLength({ min: 8 }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/),\n  body('name').trim().isLength({ min: 2, max: 50 }).escape(),\n  \n  (req, res, next) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n    next();\n  }\n];\n\n```\n\n## Rate Limiting\n\nPrevent abuse with rate limiting:\n\n```javascript\nconst rateLimit = require('express-rate-limit');\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: 'Too many requests from this IP'\n});\n\napp.use('/api/', apiLimiter);\n\n```\n\n## Security Headers\n\nEssential security headers:\n\n```javascript\nconst helmet = require('helmet');\n\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: ["'self'"],\n      styleSrc: ["'self'", "'unsafe-inline'"],\n      scriptSrc: ["'self'"]\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  }\n}));\n\n```\n\n## Database Security\n\nPrevent SQL injection:\n\n```javascript\n// Using parameterized queries with PostgreSQL\nconst query = 'SELECT * FROM users WHERE email = $1 AND status = $2';\nconst values = [userEmail, 'active'];\nconst result = await client.query(query, values);\n\n```\n\n## Error Handling\n\nDon't leak sensitive information:\n\n```javascript\nconst errorHandler = (err, req, res, next) => {\n  // Log detailed error for debugging\n  console.error(err.stack);\n  \n  // Send generic error to client\n  res.status(500).json({\n    error: process.env.NODE_ENV === 'production' \n      ? 'Internal server error' \n      : err.message\n  });\n};\n\n```\n\n## Security Checklist\n\n- ✅ Use HTTPS everywhere\n- ✅ Implement proper authentication\n- ✅ Use strong password policies\n- ✅ Validate and sanitize all input\n- ✅ Implement rate limiting\n- ✅ Use security headers\n- ✅ Keep dependencies updated\n- ✅ Log security events\n- ✅ Regular security audits\n\nBuilding secure APIs requires a layered approach. Each security measure adds a barrier against potential attacks, making your system more resilient overall.`,
    },
    {
      title: `Database Security Fundamentals`,
      description: `Essential security practices for database management, including access control, encryption, and vulnerability prevention.`, 
      date: `2025-07-10`,
      readTime: `15 min read`,
      category: `Cybersecurity`,
      link: `#`,
      slug: `database-security-fundamentals`,
      tags: [`Database`, `Security`, `SQL Injection`, `Encryption`],
      content: `# Database Security Fundamentals\n\nDatabases are the crown jewels of most applications, containing sensitive user data, business logic, and valuable intellectual property. Securing them requires a comprehensive approach that goes beyond just setting a strong password.\n\n## The Database Security Triad\n\n### Confidentiality\nEnsuring only authorized users can access data\n\n### Integrity  \nMaintaining data accuracy and preventing unauthorized modifications\n\n### Availability\nKeeping the database accessible when needed\n\n## Access Control and Authentication\n\n### Principle of Least Privilege\nGrant users only the minimum permissions necessary:\n\n```sql\n-- Create role-specific users\nCREATE USER 'app_read'@'localhost' IDENTIFIED BY 'strong_password';\nCREATE USER 'app_write'@'localhost' IDENTIFIED BY 'strong_password';\nCREATE USER 'admin'@'localhost' IDENTIFIED BY 'strong_password';\n\n-- Grant specific permissions\nGRANT SELECT ON myapp.* TO 'app_read'@'localhost';\nGRANT SELECT, INSERT, UPDATE ON myapp.orders TO 'app_write'@'localhost';\nGRANT ALL PRIVILEGES ON myapp.* TO 'admin'@'localhost';\n\n```\n\n### Multi-Factor Authentication\nEnable MFA for database administrators:\n\n```sql\n-- PostgreSQL example\nALTER USER admin_user SET password_encryption = 'scram-sha-256';\n-- Additional configuration in pg_hba.conf for certificate-based auth\n\n```\n\n## Encryption\n\n### Data at Rest\nEncrypt database files and backups:\n\n```bash\n# MySQL transparent data encryption\nALTER TABLE users ENCRYPTION='Y';\n\n# PostgreSQL with encrypted tablespace\nCREATE TABLESPACE encrypted_space \nLOCATION '/encrypted_data' \nWITH (encryption_key_id = 1);\n\n```\n\n### Data in Transit\nAlways use encrypted connections:\n\n```javascript\n// Node.js with SSL\nconst mysql = require('mysql2');\nconst connection = mysql.createConnection({\n  host: 'localhost',\n  user: 'app_user',\n  password: 'password',\n  database: 'myapp',\n  ssl: {\n    ca: fs.readFileSync('./certs/ca-cert.pem'),\n    cert: fs.readFileSync('./certs/client-cert.pem'),\n    key: fs.readFileSync('./certs/client-key.pem')\n  }\n});\n\n```\n\n### Column-Level Encryption\nEncrypt sensitive fields:\n\n```sql\n-- PostgreSQL pgcrypto\nCREATE EXTENSION IF NOT EXISTS pgcrypto;\n\n-- Encrypt sensitive data\nINSERT INTO users (email, encrypted_ssn) \nVALUES ('user@example.com', crypt('123-45-6789', gen_salt('bf')));\n\n-- Query encrypted data\nSELECT email FROM users \nWHERE encrypted_ssn = crypt('123-45-6789', encrypted_ssn);\n\n```\n\n## SQL Injection Prevention\n\n### Parameterized Queries\nAlways use prepared statements:\n\n```javascript\n// ❌ Vulnerable to SQL injection\nconst query = `SELECT * FROM users WHERE email = '${userEmail}'`;\n\n// ✅ Safe parameterized query\nconst query = 'SELECT * FROM users WHERE email = ?';\nconst results = await db.execute(query, [userEmail]);\n\n```\n\n### Input Validation\nValidate and sanitize all inputs:\n\n```javascript\nconst validator = require('validator');\n\nconst validateUserInput = (input) => {\n  // Whitelist validation\n  if (!validator.isEmail(input.email)) {\n    throw new Error('Invalid email format');\n  }\n  \n  // Length validation\n  if (input.name.length > 100) {\n    throw new Error('Name too long');\n  }\n  \n  // Escape special characters\n  return {\n    email: validator.normalizeEmail(input.email),\n    name: validator.escape(input.name)\n  };\n};\n\n```\n\n## Database Hardening\n\n### Remove Default Accounts\n\n```sql\n-- Remove or secure default accounts\nDROP USER IF EXISTS ''@'localhost';\nDROP USER IF EXISTS ''@'%';\nDROP DATABASE IF EXISTS test;\n\n```\n\n### Network Security\n\n```bash\n# Firewall rules - only allow necessary connections\niptables -A INPUT -p tcp --dport 3306 -s 192.168.1.0/24 -j ACCEPT\niptables -A INPUT -p tcp --dport 3306 -j DROP\n\n```\n\n### Regular Updates\n\n```bash\n# Keep database software updated\nsudo apt update && sudo apt upgrade mysql-server\n\n```\n\n## Monitoring and Auditing\n\n### Query Logging\nEnable comprehensive logging:\n\n```sql\n-- MySQL general query log\nSET GLOBAL general_log = 'ON';\nSET GLOBAL general_log_file = '/var/log/mysql/queries.log';\n\n-- PostgreSQL logging\nALTER SYSTEM SET log_statement = 'all';\nALTER SYSTEM SET log_connections = 'on';\nSELECT pg_reload_conf();\n\n```\n\n### Failed Login Monitoring\n\n```bash\n# Monitor MySQL error log for failed connections\ntail -f /var/log/mysql/error.log | grep \"Access denied\"\n\n```\n\n### Database Activity Monitoring\n\n```javascript\n// Application-level monitoring\nconst auditMiddleware = (req, res, next) => {\n  const auditLog = {\n    timestamp: new Date(),\n    user: req.user?.id,\n    action: req.method,\n    resource: req.path,\n    ip: req.ip\n  };\n  \n  // Log to secure audit trail\n  secureLogger.info(auditLog);\n  next();\n};\n\n```\n\n## Backup Security\n\n### Encrypted Backups\n\n```bash\n# MySQL encrypted backup\nmysqldump --single-transaction --routines --triggers myapp | \ngpg --cipher-algo AES256 --compress-algo 1 --symmetric > backup.sql.gpg\n\n```\n\n### Backup Validation\n\n```bash\n# Test backup integrity\nmysqldump myapp > test_backup.sql\nmysql test_db < test_backup.sql\n# Verify data integrity\n\n```\n\n## Compliance Considerations\n\n### GDPR/Privacy\n- Implement data anonymization\n- Enable secure data deletion\n- Maintain audit trails\n\n### SOC 2/PCI DSS\n- Regular access reviews\n- Encryption key management\n- Change management procedures\n\n## Security Checklist\n\n- ✅ Strong authentication mechanisms\n- ✅ Encrypted data at rest and in transit  \n- ✅ Parameterized queries everywhere\n- ✅ Regular security updates\n- ✅ Comprehensive monitoring\n- ✅ Secure backup procedures\n- ✅ Access control implementation\n- ✅ Regular security audits\n\nDatabase security is not a one-time setup but an ongoing process. Regular reviews, updates, and monitoring are essential for maintaining a strong security posture.`
    }
  ];
