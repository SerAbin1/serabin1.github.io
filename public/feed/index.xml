<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Abin Biju&apos;s Blog</title>
    <description>Notes on backend development, cybersecurity, and things I learn along the way.</description>
    <link>https://serabin1.github.io</link>
    <atom:link href="https://serabin1.github.io/feed" rel="self" type="application/rss+xml"/>
    <language>en-us</language>
    <lastBuildDate>Fri, 26 Dec 2025 17:01:14 GMT</lastBuildDate>
    <managingEditor>Abin Biju</managingEditor>
    <webMaster>Abin Biju</webMaster>
    
    <item>
      <title>Understanding Serialization</title>
      <link>https://serabin1.github.io/blogs/serialization</link>
      <guid isPermaLink="true">https://serabin1.github.io/blogs/serialization</guid>
      <description>Serialization is easy if, you know what it is, if not, you&apos;ll be wondering why do you need to serialize data to send it over the wire if its all bits anyways.</description>
      <content:encoded><![CDATA[<h3>Serialization</h3> Let's say you want to send these bytes over the wire: <pre><code>00000000 00000000 00000000 00000101</code></pre> How does the receiver interpret it? As integer, float, ascii string...? This is what serialization solves. It encodes the bits and how to <strong><em>interpret</em></strong> those bits. It answers questions such as: <li>In what order are fields written?</li> <li>How big is each field?</li> <li>How do we know where one field ends?</li> <li>How do we know where the message ends?</li> <li>How do we handle missing or extra fields?</li> <li>How do we handle different machines?</li>
<h4>Text based serialization protocols</h4> JSON, XML <h4>Binary serialization protocols</h4> Protocol Buffers (Protobuf), FlatBuffers, Cap'n Proto, MesssagePack, CBOR]]></content:encoded>
      <pubDate>Mon, 22 Dec 2025 00:00:00 GMT</pubDate>
      <author>Abin Biju</author>
    </item>
    <item>
      <title>Sockets or How Processes Communicate</title>
      <link>https://serabin1.github.io/blogs/sockets-or-how-processes-communicate</link>
      <guid isPermaLink="true">https://serabin1.github.io/blogs/sockets-or-how-processes-communicate</guid>
      <description>An introduction to socket programming, covering TCP/UDP protocols, client-server architecture, and inter-process communication fundamentals.</description>
      <content:encoded><![CDATA[<h1>Sockets or How Processes Communicate</h1>
<p>Socket programming is a fundamental concept in network programming that enables processes to communicate with each other across networks. Whether you're building web applications, distributed systems, or real-time communication tools, understanding sockets is crucial for any backend developer.</p>
<h2>What are Sockets?</h2>
<p>A socket is an endpoint for communication between two machines. Think of it as a telephone connection - one process "calls" another process, and once the connection is established, they can exchange data bidirectionally.</p>
<h2>Types of Sockets</h2>
<h3>TCP Sockets (Stream Sockets)</h3> <li><strong>Reliable</strong>: Guarantees data delivery and order</li> <li><strong>Connection-oriented</strong>: Establishes a connection before data transfer</li> <li><strong>Use cases</strong>: Web browsers, email, file transfers</li>
<h3>UDP Sockets (Datagram Sockets)  </h3> <li><strong>Fast</strong>: Lower overhead, no connection establishment</li> <li><strong>Unreliable</strong>: No guarantee of delivery or order</li> <li><strong>Use cases</strong>: Gaming, live streaming, DNS lookups</li>
<h2>Socket Programming Fundamentals</h2>
<h3>Server-Side Implementation</h3>
<pre><code>import socket

# Create socket
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Bind to address and port
server_socket.bind(('localhost', 8080))

# Listen for connections
server_socket.listen(5)

while True:
    client_socket, address = server_socket.accept()
    data = client_socket.recv(1024)
    client_socket.send(b"Hello from server!")
    client_socket.close()</code></pre>
<h3>Client-Side Implementation</h3>
<pre><code>import socket

# Create socket
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Connect to server
client_socket.connect(('localhost', 8080))

# Send data
client_socket.send(b"Hello from client!")

# Receive response
response = client_socket.recv(1024)
print(response.decode())

client_socket.close()</code></pre>
<h2>Best Practices</h2>
<p>1. <strong>Error Handling</strong>: Always implement proper error handling for network operations<br>2. <strong>Resource Management</strong>: Close sockets properly to avoid resource leaks<br>3. <strong>Security</strong>: Validate input data and implement authentication when needed<br>4. <strong>Performance</strong>: Use connection pooling for high-traffic applications</p>
<h2>Real-World Applications</h2>
<p>Socket programming powers many technologies we use daily:<br><li><strong>Web Servers</strong>: HTTP communication between browsers and servers</li><br><li><strong>Chat Applications</strong>: Real-time messaging systems</li><br><li><strong>Database Connections</strong>: Client-server database communication</li><br><li><strong>API Services</strong>: RESTful and GraphQL API endpoints</li></p>
<p>Understanding sockets gives you the foundation to build robust, scalable network applications and debug network-related issues effectively.</p>]]></content:encoded>
      <pubDate>Tue, 05 Aug 2025 00:00:00 GMT</pubDate>
      <author>Abin Biju</author>
    </item>
  </channel>
</rss>